/**** I, Omri Goldberg (208938985) assert that the work I submitted is entirely my own.
I have not received any part from any other student in the class (or other source),
nor did I give parts of it for use to others. I have clearly marked in the comments
of my program any code taken from an external source. *****/

:- use_module('/home/omrigo13/SATSOLVERS/beeCompiler/bCompiler',[bCompile/2]).
:- use_module('/home/omrigo13/SATSOLVERS/satsolver/satsolver',[sat/1]).
:- use_module('/home/omrigo13/SATSOLVERS/bApplications/auxs/auxRunExpr',[runExpr/5, decodeIntArray/2,decodeInt/2]).
:- use_module('/home/omrigo13/SATSOLVERS/bApplications/auxs/auxRunExprAll',[runExprAll/5]).

% Task 1: kakuroVerify
% Signature: kakuroVerify(Instance, Solution)/2
% Purpose: succeeds if and only if its first argument represents a legal
% Kakuro instance, and its second argument represents a legal solution to that instance.
kakuroVerify(Instance, Solution) :- 
	verifyInstance(Instance,Solution), 
	verifySolution(Solution).


verifySolution([]) :- !.
verifySolution([Sum = FBlock | RBlocks]):- 
	sumlist(FBlock,Sum), 
	diffelements(FBlock), 
	leqNineBlock(FBlock), 
	verifySolution(RBlocks).


verifyInstance([],[]) :- !.
verifyInstance([Value = InstanceBlock|Instance],[Value = SolutionBlock|Solution]):- 
	length(InstanceBlock,N),
	length(SolutionBlock,N),
	verifyInstance(Instance,Solution).


diffelements([]).
diffelements([X|Xs]):-
    \+ member(X,Xs), 
	diffelements(Xs).


leqNineBlock([]) :- !.
leqNineBlock([Cur|Rest]) :- 
	Cur > 0 , 
	Cur < 10, 
	leqNineBlock(Rest).  


% Task 2: kakuroEncode
% Signature: kakuroEncode(Instance,Map,Cons)/3
% Purpose: The predicate takes an instance of Kakuro, and encodes
% it to a set of BEE constraints Constraints which is satisfiable 
% if and only if the mapping of BEE integer variables specified 
% in Map is a solution to the Kakuro instance.
kakuroEncode(Instance,Map,Cons) :-
	Instance = Map,
	getAllBlocks(Instance, Blocks), 
	flatten(Blocks,FlattenedBlock), 
	sort(FlattenedBlock,SortedBlock), 
	getDomain(SortedBlock,DomainCons),
	getConstraints(Instance,RConstraints), 
	append(DomainCons,RConstraints,Cons).


getAllBlocks([],[]) :- !.
getAllBlocks([_ = CBlock|RBlocks], [CBlock|RRes]) :- getAllBlocks(RBlocks,RRes).


getConstraints([],[]).
getConstraints([CVal = CVals|RClues], Res) :- 
	getAllDiff(CVals,AllDiffCons), 
	getSum(CVal,CVals,SumCons), 
	append([AllDiffCons],[SumCons],AppendToRes), 
	getConstraints(RClues,NewRes),
	append(AppendToRes,NewRes,Res).


getAllDiff(CVals,int_array_allDiff(CVals)).


getSum(CVal,CVals,int_array_plus(CVals,CVal)).


getDomain([],[]) :- !.
getDomain([FVal|RNums],[new_int(FVal,1,9)|RDomain]) :- getDomain(RNums,RDomain).


% Task 3: kakuroDecode
% Signature: kakuroDecode(Map,Solution)/2
% Purpose: The predicate decodes the Map of variables generated by 
% kakuroEncode/3 to a Kakuro solution.
kakuroDecode([],[]) :- !.
kakuroDecode([Value = Block|RestMap],[Value = DBlock|RestSolution]) :- 
	bDecode:decodeIntArray(Block,DBlock), kakuroDecode(RestMap,RestSolution).


% Task 4: kakuroSolve
% Signature: kakuroSolve(Instance,Solution)/2
% Purpose: The predicate takes a Kakuro instance, solves it using BEE.
kakuroSolve(Instance,Solution) :-
    runExpr(Instance,Solution,ex3:kakuroEncode,ex3:kakuroDecode,ex3:kakuroVerify).


% Task 5: Killer Sudoku Verifier
% Signature: verify_killer(Instance,Solution)/2
% Purpose: succeeds if and only if its second argument Solution represents
% a legal Killer Sudoku solution for the instance Instance in its first argument.
% Otherwise, verify_killer should fail.
verify_killer(killer(Hints),Solution) :- 
	\+(verifyHints(Hints,Solution)),
	\+(verifyRows(Solution)),
	\+(verifyCols(Solution)),
	\+(verifyBoxes(Solution)),
	\+(verifyMoves(Solution)),
	\+(verifyAdjCellsH(Solution)),										 
	\+(verifyAdjCellsV(Solution)),
	\+(verifyMove(Solution)).
	
	
verifyRows(Solution) :- 
	member(cell(X,Y1) = Val,Solution), 
	member(cell(X,Y2) = Val,Solution),
	Y2 \= Y1,!.


verifyCols(Solution) :- 
	member(cell(X1,Y) = Val,Solution), 
	member(cell(X2,Y) = Val,Solution),
	X1 \= X2,!.


verifyBoxes(Solution) :- 
	(member(R1,[1,4,7]),
	member(C1,[1,4,7]),
	RN is R1 + 2, 
	CN is C1 + 2,
	member(cell(X1,Y1) = Val,Solution),
	member(cell(X2,Y2) = Val,Solution),
	X1 \= X2,
	Y1 \= Y2,
	between(R1,RN,X1),
	between(R1,RN,X2),
	between(C1,CN,Y1),
	between(C1,CN,Y2)),!.


verifyMove(Solution) :- 						
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+2 , Y1 is Y2-1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+2 , Y1 is Y2+1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-2 , Y1 is Y2-1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-2 , Y1 is Y2+1),!;								
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+1 , Y1 is Y2+2),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+1 , Y1 is Y2-2),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-1 , Y1 is Y2+2),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-1 , Y1 is Y2-2),!.


verifyMoves(Solution) :-
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-1 , Y1 is Y2-1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+1 , Y1 is Y2+1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+1 , Y1 is Y2-1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-1 , Y1 is Y2+1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2 , Y1 is Y2+1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2 , Y1 is Y2-1),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2+1 , Y1 is Y2),!;
	member(cell(X1,Y1) = Val,Solution), member(cell(X2,Y2) = Val,Solution), (X1 is X2-1 , Y1 is Y2),!.


verifyAdjCellsH(Solution) :-
	member(cell(X1,Y1) = Val,Solution), NewVal is Val+1, member(cell(X2,Y2) = NewVal,Solution), (X1 is X2-1 , Y1 is Y2),!;
	member(cell(X1,Y1) = Val,Solution), NewVal is Val+1, member(cell(X2,Y2) = NewVal,Solution), (X1 is X2+1 , Y1 is Y2),!.


verifyAdjCellsV(Solution) :-
	member(cell(X1,Y1) = Val,Solution), NewVal is Val+1, member(cell(X2,Y2) = NewVal,Solution), (X1 is X2 , Y1 is Y2+1),!;
	member(cell(X1,Y1) = Val,Solution), NewVal is Val+1, member(cell(X2,Y2) = NewVal,Solution), (X1 is X2 , Y1 is Y2-1),!.


verifyHints(Hints,Solution) :-															
	member(cell(X,Y) = Val1, Hints), member(cell(X,Y) = Val2, Solution), Val1 \= Val2.


% Task 6: Killer Sudoku Encoder
% Signature: encode_killer(Instance, Map, Constraints)/3
% Purpose: given a Killer Sudoku instance which is represented by a
% list of hints (assignment constraints) Instance = killer(Hints) unifies Map with a rep-
% resentation of the instance as a list of 81 terms of the form cell(I,J) = Value, where
% I and J are Prolog integers representing the index of the cell, and Value represents a
% BEE integer between 1 and 9 encoded in Constraints. A call to the predicate instanti-
% ates Constraints with a set of BEE constraints such that the satisfying assignments for
% Constraints correspond to solutions of the Killer Sudoku instance Instance and bind
% the variables in Map to represent the corresponding integer values.
encode_killer(killer(Hints), Map, AllCons) :- 
	findall(cell(X,Y) = _, (between(1,9,X) , between(1,9,Y)),Map),
	build(Hints,Map),
	include(noVal,Map,NoHintsMap),
	buildConsVals(NoHintsMap,Cons1),
	buildRows(Map,1,Rows), 
	buildConsRows(Rows,Cons2),
	buildCols(Map,1,Columns), 
	buildConsCols(Columns,Cons3),
	buildBoxes(Map,Boxes), 
	buildConsBoxes(Boxes,Cons4),
	buildConstKings(Map,Map,Cons5),
	buildConsAdjCells(Map,Map,Cons6),
	appendAllCons(Cons1,Cons2,Cons3,Cons4,Cons5,Cons6,AllCons),!.

noVal(cell(_,_) = Val) :- var(Val).


build([],_) :- !.
build([cell(X,Y) = Value | RCells], Map) :- member(cell(X,Y) = Value, Map),build(RCells,Map).


buildConsRows(Rows,Cons) :- buildConsCont(Rows,Cons).							 

cellsRows(Index,cell(Index,_) = _).

buildRows(Map,Index,Rows) :-
	Index < 10,
	include(cellsRows(Index),Map,ResRows),
	onlyVals(ResRows,ResValRows),
	NewIndex is Index + 1,
	buildRows(Map,NewIndex,OtherRows),
	append([ResValRows],OtherRows,Rows).
buildRows(_,10,[]).


buildConsCols(Columns,Cons) :- buildConsCont(Columns,Cons).							 

cellsColumns(Index,cell(_,Index) = _).

buildCols(Map,Index,Columns) :-
	Index < 10,
	include(cellsColumns(Index),Map,ResColumns),
	onlyVals(ResColumns,ResValColumns),
	NewIndex is Index + 1,
	buildCols(Map,NewIndex,OtherColumns),
	append([ResValColumns],OtherColumns,Columns).
buildCols(_,10,[]).


buildConsBoxes(Boxes,Cons) :- buildConsCont(Boxes,Cons).

buildBoxes(Map,Boxes) :- 
	include(uniqueBox(1,1),Map,Box11),
	include(uniqueBox(1,4),Map,Box14),
	include(uniqueBox(1,7),Map,Box17),
	include(uniqueBox(4,1),Map,Box41),
	include(uniqueBox(4,4),Map,Box44),
	include(uniqueBox(4,7),Map,Box47),
	include(uniqueBox(7,1),Map,Box71),
	include(uniqueBox(7,4),Map,Box74),
	include(uniqueBox(7,7),Map,Box77),
	buildBoxesCont([Box11,Box14,Box17,Box41,Box44,Box47,Box71,Box74,Box77],Boxes).

uniqueBox(R1,C1,cell(X,Y) = _) :- 
	RN is R1 + 2, 
	CN is C1 + 2, 
	between(R1,RN,X), 
	between(C1,CN,Y).

buildBoxesCont([CurrBox|RestBoxes],ValBoxes) :- 
	onlyVals(CurrBox,ValBox),
	buildBoxesCont(RestBoxes,RestValBox), 
	append([ValBox],RestValBox,ValBoxes).
buildBoxesCont([],[]).	


buildConsCont([Line|RestLine],[int_array_allDiff(Line)|RCons]):- 
	buildConsCont(RestLine,RCons).
buildConsCont([],[]).


buildConstKings(Map,[cell(X,Y) = Val| RestMap],Cons):- 
	buildKK(Val,Map,X,Y,KKNeighbors),														
	buildConsContKing(Val,KKNeighbors,CurCons),
	buildConstKings(Map,RestMap,RestCons),
	append(CurCons,RestCons,Cons).
buildConstKings(_,[],[]).

buildKK(Values,Map,X,Y,KK):-
	XM is X - 2,XP is X + 2, YM is Y - 2, YP is Y + 2 ,
	include(my_radious(XM,XP,YM,YP),Map,First_radious),
	delete(First_radious, cell(X,Y) = Values, R1),
	delete(R1,cell(XM,YM) = _, R2),
	delete(R2,cell(XM,YP) = _, R3),
	delete(R3,cell(XP,YM) = _, R4),
	delete(R4,cell(XP,YP) = _, R5),
	delete(R5,cell(XM,Y) = _, R6),
	delete(R6,cell(XP,Y) = _, R7),
	delete(R7,cell(X,YP) = _, R8),
	delete(R8,cell(X,YM) = _, Neighbors),
	onlyVals(Neighbors,KK).

	
my_radious(XM,XP,YM,YP, cell(X,Y) = _ ) :- between(XM,XP,X),between(YM,YP,Y).

buildConsContKing(Val,[Neighbor|RKingNeighbors],[int_neq(Val,Neighbor)|RCons]):-
	buildConsContKing(Val,RKingNeighbors,RCons).
buildConsContKing(_,[],[]).	


buildConsVals([cell(_,_) = Val|RestMap],[new_int(Val,1,9)|RCons]) :- 
	buildConsVals(RestMap,RCons).
buildConsVals([],[]) :- !.


buildConsAdjCells(Map,[cell(X,Y) = Val|RestMap],Cons) :- 
	buildAdjCells(Map,X,Y,Neighbors),
	buildConsAdjCellsCont(Val,Neighbors,CurCons),
	buildConsAdjCells(Map,RestMap,RestCons),
	append(CurCons,RestCons,Cons).
buildConsAdjCells(_,[],[]).

buildAdjCells(Map,X,Y,Neighbors) :- 
	XM is X - 1, 
	XP is X + 1,
	YM is Y - 1, 
	YP is Y + 1,
	include(adjNeighbors(XM,XP,YM,YP,X,Y),Map,Result),
	onlyVals(Result,Neighbors).

adjNeighbors(XM,_,_,_,_,Y,cell(XM,Y) = _).
adjNeighbors(_,XP,_,_,_,Y,cell(XP,Y) = _).
adjNeighbors(_,_,YM,_,X,_,cell(X,YM) = _).
adjNeighbors(_,_,_,YP,X,_,cell(X,YP) = _).


buildConsAdjCellsCont(_,[],[]) :- !.	
buildConsAdjCellsCont(Val, [Neighbor|RestAdjacentNeighbors],Cons):-
	Constrains = [new_int(V1,2,10),int_plus(Val,1,V1),int_neq(V1,Neighbor),
	new_int(V2,2,10),int_plus(Neighbor,1,V2),int_neq(V2,Val)],
	buildConsAdjCellsCont(Val,RestAdjacentNeighbors,RCons),
	append(Constrains,RCons,Cons).


appendAllCons(C1,C2,C3,C4,C5,C6,Cons) :- 
	append(C1,C2,C1C2), 
	append(C1C2,C3,C1C2C3), 
	append(C1C2C3,C4,C1C2C3C4), 
	append(C1C2C3C4,C5,C1C2C3C4C5),
	append(C1C2C3C4C5,C6,Cons).

solve_killer(Instance, Solution) :-
	runExpr(Instance, Solution, encode_killer, decode_killer, verify_killer).


% Task 7: Killer Sudoku Decoder
% Signature: decode_killer(Map,Solution)/2
% Purpose: creates from the given Map a corresponding solution 
% in the format which is a list of (81) assignment constraints.
decode_killer([],[]) :- !.
decode_killer([cell(X,Y) = EncodeValue|RM], [cell(X,Y) = DecodeValue|RS]) :-
    bDecode:decodeInt(EncodeValue,DecodeValue),
    decode_killer(RM,RS).			


% Task 8: Legal Killer Sudoku Instance
% Signature: all_killer(Instance, Solutions)/2
% Purpose: given an instance of a Killer Sudoku puzzle unifies Solutions with a list of all 
% possible solutions to Instance. This predicate must be deterministic. 
% If Instance is a legal Killer Sudoku instance then Solutions will contain exactly one solution.
all_killer(Instance, Solutions):-
	runExprAll(Instance, Solutions, ex3:encode_killer, ex3:decode_killer, ex3:verify_killer).

encode_killer(killer(Hints),Map,(NeededBooleans,NeededInts),AllCons) :-
	findall(cell(X,Y) = _, (between(1,9,X) , between(1,9,Y)),Map),
	build(Hints,Map),
	include(noVal,Map,NoHintsMap),
	buildConsVals(NoHintsMap,Cons1),
	buildRows(Map,1,Rows), 
	buildConsRows(Rows,Cons2),
	buildCols(Map,1,Columns), 
	buildConsCols(Columns,Cons3),
	buildBoxes(Map,Boxes), 
	buildConsBoxes(Boxes,Cons4),
	buildConstKings(Map,Map,Cons5),
	buildConsAdjCells(Map,Map,Cons6),
	appendAllCons(Cons1,Cons2,Cons3,Cons4,Cons5,Cons6,AllCons),
	NeededBooleans = [],
	onlyVals(NoHintsMap,ValRes),
    NeededInts = ValRes,!.


onlyVals([cell(_,_) = Value|RCells], [Value|RVals]) :- onlyVals(RCells,RVals).
onlyVals([],[]).